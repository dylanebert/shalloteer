
import { z } from 'zod';
import fs from 'fs';
import path from 'path';

function toCamelCase(str: string): string {
  return str.replace(/-([a-z])/g, (_, letter) => letter.toUpperCase());
}

function zodToTypeScript(schema: z.ZodTypeAny, indent = 0): string {
  const spaces = ' '.repeat(indent);

  if (schema instanceof z.ZodOptional) {
    return `${zodToTypeScript(schema._def.innerType, indent)}?`;
  }

  if (schema instanceof z.ZodUnion) {
    const types = schema._def.options.map((opt: z.ZodTypeAny) => zodToTypeScript(opt, indent));
    return types.join(' | ');
  }

  if (schema instanceof z.ZodLiteral) {
    const value = schema._def.value;
    return typeof value === 'string' ? `'${value}'` : String(value);
  }

  if (schema instanceof z.ZodEnum) {
    return schema._def.values.map((v: string) => `'${v}'`).join(' | ');
  }

  if (schema instanceof z.ZodString) {
    return 'string';
  }

  if (schema instanceof z.ZodNumber) {
    return 'number';
  }

  if (schema instanceof z.ZodBoolean) {
    return 'boolean';
  }

  if (schema instanceof z.ZodObject) {
    const shape = schema._def.shape || schema.shape;
    const fields = Object.entries(shape).map(([key, value]) => {
      const camelKey = toCamelCase(key);
      const type = zodToTypeScript(value as z.ZodTypeAny, indent + 2);
      return `${spaces}  ${camelKey}: ${type};`;
    });
    return `{\n${fields.join('\n')}\n${spaces}}`;
  }

  if (schema instanceof z.ZodNever) {
    return 'never';
  }

  return 'any';
}

export function generateComponentTypes(schemas: Record<string, z.ZodTypeAny>): string {
  const interfaces: string[] = [];

  interfaces.push(`// Auto-generated component prop types from Zod schemas
// DO NOT EDIT - Generated by src/jsx/types/generate.ts

export type Vector2 = { x: number; y: number } | number | string;
export type Vector3 = { x: number; y: number; z: number } | number | string;
export type Color = string | number;
`);

  for (const [name, schema] of Object.entries(schemas)) {
    const interfaceName = `${toCamelCase(name)}Props`;
    
    if (schema instanceof z.ZodObject) {
      const shape = schema._def.shape || schema.shape;
      const fields = Object.entries(shape).map(([key, value]) => {
        const camelKey = toCamelCase(key);
        let type = zodToTypeScript(value as z.ZodTypeAny);
        
        if (key === 'pos' || key === 'scale' || key === 'euler') {
          type = 'Vector3';
        } else if (key === 'color' || key.includes('color') || key.includes('Color')) {
          type = 'Color';
        }
        
        return `  ${camelKey}?: ${type};`;
      });

      interfaces.push(`export interface ${interfaceName} {
${fields.join('\n')}
}
`);
    }
  }

  interfaces.push(`export interface EntityProps {
  transform?: TransformProps;
  body?: BodyProps;
  collider?: ColliderProps;
  renderer?: RendererProps;
  [key: string]: any;
}
`);

  interfaces.push(`export interface StaticPartProps extends EntityProps {
  pos?: Vector3;
  shape?: 'box' | 'sphere' | 'cylinder' | 'capsule' | 'cone' | 'torus' | 'plane';
  size?: Vector3;
  color?: Color;
}

export interface DynamicPartProps extends EntityProps {
  pos?: Vector3;
  shape?: 'box' | 'sphere' | 'cylinder' | 'capsule' | 'cone' | 'torus' | 'plane';
  size?: Vector3;
  color?: Color;
  mass?: number;
}

export interface KinematicPartProps extends EntityProps {
  pos?: Vector3;
  shape?: 'box' | 'sphere' | 'cylinder' | 'capsule' | 'cone' | 'torus' | 'plane';
  size?: Vector3;
  color?: Color;
}

export interface PlayerProps extends EntityProps {
  pos?: Vector3;
  speed?: number;
  jumpHeight?: number;
}

export interface CameraProps extends EntityProps {
  orbitCamera?: OrbitCameraProps;
}

export interface AmbientLightProps extends EntityProps {
  skyColor?: Color;
  groundColor?: Color;
  intensity?: number;
}

export interface DirectionalLightProps extends EntityProps {
  color?: Color;
  intensity?: number;
  direction?: Vector3;
  castShadow?: boolean;
}

export interface WorldProps {
  canvas: string;
  sky?: Color;
  children?: React.ReactNode;
}
`);

  return interfaces.join('\n');
}

if (import.meta.main) {
  const { 
    transformComponentSchema,
    bodyComponentSchema,
    colliderComponentSchema,
    rendererComponentSchema,
    orbitCameraComponentSchema
  } = await import('../../core/validation/schemas');

  const schemas = {
    transform: transformComponentSchema,
    body: bodyComponentSchema,
    collider: colliderComponentSchema,
    renderer: rendererComponentSchema,
    'orbit-camera': orbitCameraComponentSchema,
  };

  const typesContent = generateComponentTypes(schemas);
  const outputPath = path.join(import.meta.dir, 'components.d.ts');
  
  fs.writeFileSync(outputPath, typesContent);
  console.log(`Generated types at ${outputPath}`);
}